{"version":3,"file":"component---src-pages-development-components-message-queues-stores-md-c578a1e5e4afe4a7956b.js","mappings":"4QAQaA,EAAe,GACtBC,EAAc,CAClBD,aAAAA,GAEIE,EAAYC,EAAAA,EACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,GACF,YACD,OAAO,SAACJ,GAAD,UAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,eAG5E,eACE,GAAM,gCADR,iCAGA,0BAAW,uBAAYC,WAAW,KAAvB,qBAAX,0GACA,eACE,GAAM,uBADR,wBAGA,0NACA,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBADZ,0EAIL,qDAAsC,uBAAYA,WAAW,KAAvB,WAAtC,eAAwG,uBAAYA,WAAW,KAAvB,4CAAxG,MACA,8GAA+F,uBAAYA,WAAW,KAAvB,uBAA/F,0DAAwN,uBAAYA,WAAW,KAAvB,YAAxN,8BACA,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBADZ,gvDAgDL,0EAA2D,uBAAYA,WAAW,KAAvB,uBAA3D,kBAA4I,uBAAYA,WAAW,KAAvB,YAA5I,4LACA,eACE,GAAM,0BADR,2BAGA,mBAAG,cAAGA,WAAW,IACb,KAAQ,8FADT,aAAH,gEAGA,yHACA,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBADZ,oMAIL,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBADZ,q/CAmCL,gGAAiF,uBAAYA,WAAW,KAAvB,gBAAjF,qBAA8J,uBAAYA,WAAW,KAAvB,YAA9J,YAQJJ,EAAWK,gBAAiB","sources":["webpack://commerce-php/./src/pages/development/components/message-queues/stores.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/commerce-php/commerce-php/node_modules/@adobe/gatsby-theme-aio/src/components/MDXFilter/index.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"requests-for-specific-stores\"\n    }}>{`Requests for specific stores`}</h1>\n    <p>{`The `}<inlineCode parentName=\"p\">{`Magento_AmqpStore`}</inlineCode>{` module provides the ability for message queues to process asynchronous requests for specific stores.`}</p>\n    <h2 {...{\n      \"id\": \"processing-messages\"\n    }}>{`Processing messages`}</h2>\n    <p>{`Adobe Commerce and Magento Open Source process each message that is sent to the Message Queue Framework, adding information about the current store. The following plugin implements this behavior:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`app/code/Magento/AmqpStore/Plugin/Framework/Amqp/Bulk/Exchange.php\n`}</code></pre>\n    <p>{`The plugin executes before the `}<inlineCode parentName=\"p\">{`enqueue`}</inlineCode>{` method in `}<inlineCode parentName=\"p\">{`Magento\\\\Framework\\\\Amqp\\\\Bulk\\\\Exchange`}</inlineCode>{`.`}</p>\n    <p>{`By default, each AMQP message contains a list of properties. One of these properties is `}<inlineCode parentName=\"p\">{`application_headers`}</inlineCode>{`, and these headers are used for transfer the current `}<inlineCode parentName=\"p\">{`store_id`}</inlineCode>{` into the RabbitMQ queue.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`public function beforeEnqueue(SubjectExchange $subject, $topic, array $envelopes)\n{\n    try {\n        $storeId = $this->storeManager->getStore()->getId();\n    } catch (NoSuchEntityException $e) {\n        $errorMessage = sprintf(\n            \"Can't get current storeId and inject to amqp message. Error %s.\",\n            $e->getMessage()\n        );\n        $this->logger->error($errorMessage);\n        throw new \\\\LogicException($errorMessage);\n    }\n    $updatedEnvelopes = [];\n    foreach ($envelopes as $envelope) {\n        $properties = $envelope->getProperties();\n        if (!isset($properties)) {\n            $properties = [];\n        }\n        if (isset($properties['application_headers'])) {\n            $headers = $properties['application_headers'];\n            if ($headers instanceof AMQPTable) {\n                try {\n                    $headers->set('store_id', $storeId);\n                } catch (AMQPInvalidArgumentException $ea) {\n                    $errorMessage = sprintf(\"Can't set storeId to amqp message. Error %s.\", $ea->getMessage());\n                    $this->logger->error($errorMessage);\n                    throw new AMQPInvalidArgumentException($errorMessage);\n                }\n                $properties['application_headers'] = $headers;\n            }\n        } else {\n            $properties['application_headers'] = new AMQPTable(['store_id' => $storeId]);\n        }\n        $updatedEnvelopes[] = $this->envelopeFactory->create(\n            [\n                'body' => $envelope->getBody(),\n                'properties' => $properties\n            ]\n        );\n    }\n    if (!empty($updatedEnvelopes)) {\n        $envelopes = $updatedEnvelopes;\n    }\n    return [$topic, $envelopes];\n}\n`}</code></pre>\n    <p>{`In this example, you can see that the plugin checks `}<inlineCode parentName=\"p\">{`application_headers`}</inlineCode>{` and adds the `}<inlineCode parentName=\"p\">{`store_id`}</inlineCode>{` parameter. If the headers do not exist, then plugin creates them. As a result, each RabbitMQ message receives information about the store that is affected by an asynchronous request.`}</p>\n    <h2 {...{\n      \"id\": \"processing-by-consumer\"\n    }}>{`Processing by consumer`}</h2>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"https://devdocs.magento.com/guides/v2.4/config-guide/cli/config-cli-subcommands-queue.html\"\n      }}>{`Consumers`}</a>{` pick up messages from the RabbitMQ queue and process them.`}</p>\n    <p>{`On a step when a consumer reads a message, the extension executes an around plugin, as shown here:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`Magento\\\\AmqpStore\\\\Plugin\\\\AsynchronousOperations\\\\MassConsumerEnvelopeCallback::aroundExecute(SubjectMassConsumerEnvelopeCallback $subject, callable $proceed, EnvelopeInterface $message)\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`public function aroundExecute(SubjectMassConsumerEnvelopeCallback $subject, callable $proceed, EnvelopeInterface $message)\n    {\n        $amqpProperties = $message->getProperties();\n        if (isset($amqpProperties['application_headers'])) {\n            $headers = $amqpProperties['application_headers'];\n            if ($headers instanceof AMQPTable) {\n                $headers = $headers->getNativeData();\n            }\n            if (isset($headers['store_id'])) {\n                $storeId = $headers['store_id'];\n                try {\n                    $currentStoreId = $this->storeManager->getStore()->getId();\n                } catch (NoSuchEntityException $e) {\n                    $this->logger->error(\n                        sprintf(\n                            \"Can't set currentStoreId during processing queue. Message rejected. Error %s.\",\n                            $e->getMessage()\n                        )\n                    );\n                    $subject->getQueue()->reject($message, false, $e->getMessage());\n                    return;\n                }\n                if (isset($storeId) && $storeId !== $currentStoreId) {\n                    $this->storeManager->setCurrentStore($storeId);\n                }\n            }\n        }\n        $proceed($message);\n        if (isset($storeId, $currentStoreId) && $storeId !== $currentStoreId) {\n            $this->storeManager->setCurrentStore($currentStoreId);//restore original store value\n        }\n    }\n`}</code></pre>\n    <p>{`The plugin checks the message headers and sets the current store value in `}<inlineCode parentName=\"p\">{`storeManager`}</inlineCode>{` to the received `}<inlineCode parentName=\"p\">{`store_id`}</inlineCode>{` value.`}</p>\n    {\n      /* Link definitions */\n    }\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"sourceRoot":""}